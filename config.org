#+TITLE: aeggy's emacs config
#+AUTHOR: aeggy

TODO: use use-package :custom instead of (setq), or make an alternative (:set)
TODO: add some sort of a dashboard
TODO: add a tab bar (centaur-tabs?)
TODO: add quickrun https://github.com/emacsorphanage/quickrun
TODO: add a translator tool (https://github.com/lorniu/go-translate perhaps)
* Package management
** Straight
*** TODO Load
This contains legacy code; fix it.

#+begin_src emacs-lisp
  (defvar bootstrap-version)
  (let ((bootstrap-file
         (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
        (bootstrap-version 5))
    (unless (file-exists-p bootstrap-file)
      (with-current-buffer
          (url-retrieve-synchronously
           "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
           'silent 'inhibit-cookies)
        (goto-char (point-max))
        (eval-print-last-sexp)))
    (load bootstrap-file nil 'nomessage))
#+end_src
** use-package
Load use-package and make it install all packages by default
#+begin_src emacs-lisp
  (straight-use-package 'use-package)
  (setq straight-use-package-by-default t)

  (use-package diminish)
#+end_src
*** repo finder
#+begin_src emacs-lisp
  (defun my-straight-get-repo (package insert)
    "Echo repo to the inputted package if it exists."
    (interactive
     (list
      (intern
       (completing-read "Package: "
                        (straight-recipes-list)
                        (lambda (_) t)
                        'require-match))
      current-prefix-arg))


    (let ((recipe (cdr (straight-recipes-retrieve package)))
          (url))
      (if (eq (plist-get recipe :host) 'github)
          (progn
            (setq url (concat "https://github.com/" (plist-get recipe :repo)))
            (message url)
            (when insert (insert url)))
        (message "not hosted on github"))))
#+end_src
* Behavior
** Libraries
#+begin_example
  (use-package s)
  (use-package f)
  (use-package dash)
#+end_example
** Path
Inherit PATH from the shell
#+begin_src emacs-lisp
  (use-package exec-path-from-shell
    :config
    (exec-path-from-shell-initialize))
#+end_src
** Initial buffer
#+begin_src emacs-lisp
  (setq inhibit-startup-screen t) ; don't show the info startup screen
  (setq inhibit-startup-message t) ; ... and the message
  (setq initial-scratch-message nil) ; remove all text from the scratch buffer
  (defun display-startup-echo-area-message ()
    (message "Welcome."))
  (setq inhibit-startup-message t)
  (setq initial-major-mode 'org-mode) ; create scratch buffer with org mode
#+end_src
** Startup
Resume the previous session
#+begin_src emacs-lisp
  (desktop-save-mode 1)
#+end_src
** Loading
Automatically revert a buffer when it changes on disk
#+begin_src emacs-lisp
  (global-auto-revert-mode 0)
#+end_src
** TODO Scrolling
Smoother scrolling
#+begin_src emacs-lisp
  (setq scroll-margin 10)
  (setq scroll-step 1)
  (setq scroll-conservatively 100000)
  (setq next-line-add-newlines nil)
  (setq scroll-preserve-screen-position t)
#+end_src
*** Mouse
#+begin_src emacs-lisp
  (set-mouse-color "yellow")
  (setq mouse-wheel-follow-mouse t) ; scroll buffer over which the mouse is
  (setq mouse-wheel-scroll-amount '(1
                                    ((shift)
                                     . hscroll)
                                    ((meta))
                                    ((control)
                                     . text-scale))) ; add various modifiers to scrolling
#+end_src
** Indent guides
Show lines that highlight the indentation levels
#+begin_src emacs-lisp
  (use-package highlight-indent-guides
    :config
    (setq highlight-indent-guides-method 'character
          highlight-indent-guides-auto-enabled nil)
    (set-face-background 'highlight-indent-guides-odd-face "darkgray")
    (set-face-background 'highlight-indent-guides-even-face "dimgray")
    (set-face-foreground 'highlight-indent-guides-character-face "dimgray")
    (add-hook 'prog-mode-hook 'highlight-indent-guides-mode))
#+end_src
** Quitting
TODO: add support for quitting any minibuffer dialogue with ESC
** Dialogs
Make all prompts y-or-n
#+begin_src emacs-lisp
  (fset 'yes-or-no-p 'y-or-n-p)
#+end_src
** Saving
Clean up the whitespace when saving
#+begin_src emacs-lisp
  (add-hook 'before-save-hook 'whitespace-cleanup)
#+end_src
** Recent
#+begin_src emacs-lisp
  (recentf-mode 1)
#+end_src
** Text replacing
Replace selection when you start typing
#+begin_src emacs-lisp
  (delete-selection-mode t)
#+end_src
** Echoing status
*** Keystrokes
#+begin_src emacs-lisp
  (setq echo-keystrokes 0.1) ; show keystrokes right away
#+end_src
** Parenthesis highlighting
#+begin_src emacs-lisp
  (use-package rainbow-delimiters
    :config
    (add-hook 'prog-mode-hook #'rainbow-delimiters-mode))
#+end_src
** Prettify symbols
TODO: add more characters
TODO: add ligatures
#+begin_src emacs-lisp
  (setq prettify-symbols-unprettify-at-point 'right-edge)
  (setq inhibit-compacting-font-caches t)
  (add-hook 'prog-mode-hook #'prettify-symbols-mode)
#+end_src
** TODO Undo
#+begin_src emacs-lisp
  (use-package undo-tree
    :after evil
    :diminish undo-tree-mode
    :config
    (setq undo-tree-history-directory-alist `(("." . ,(expand-file-name "tmp/undo" user-emacs-directory))))
    (setq undo-tree-auto-save-history t)
    (setq undo-tree-visualizer-timestamps t)
    (setq undo-tree-visualizer-diff t)
    (global-undo-tree-mode)
    (setq evil-undo-system 'undo-tree))
#+end_src
*** TODO Remove undo-tree eventually
** Tooltips
#+begin_src emacs-lisp
  (setq x-gtk-use-system-tooltips nil)
#+end_src
** GUI
#+begin_src emacs-lisp
  (setq frame-resize-pixelwise t) ; make emacs frames maximize fully
#+end_src
** Jump highlighting
Alternative to beacon
#+begin_src emacs-lisp
  (require 'pulse)
  (defun pulse-line (&rest _)
    "Pulse the current line."
    (pulse-momentary-highlight-one-line (point)))

  (set-face-background 'pulse-highlight-start-face "yellow")

  (dolist (command '(scroll-up-command scroll-down-command
                                       recenter-top-bottom other-window))
    (advice-add command :after #'pulse-line))
#+end_src
** expand-region
#+begin_src emacs-lisp
(use-package expand-region
  :config
  (global-set-key (kbd "C-=") #'er/expand-region))
#+end_src
** TODO smartparens
#+begin_src emacs-lisp
(use-package smartparens
  :config
  (require 'smartparens-config)
  (smartparens-global-mode t))
#+end_src
** Fix annoying keys
*** Audio keys
These keys get captured in Xorg with WSL
#+begin_src emacs-lisp
(global-set-key (kbd "<XF86AudioLowerVolume>") #'ignore)
(global-set-key (kbd "<XF86AudioRaiseVolume>") #'ignore)
(global-set-key (kbd "<XF86AudioMute>") #'ignore)
#+end_src
** read-only
#+begin_src emacs-lisp
  (setq view-read-only t)
#+end_src
** upcase / downcase / capitalize
#+begin_src emacs-lisp
  (global-set-key (kbd "M-u") #'upcase-dwim)
  (global-set-key (kbd "M-l") #'downcase-dwim)
  (global-set-key (kbd "M-c") #'capitalize-dwim)
#+end_src
** Uniquify
#+begin_src emacs-lisp
  (use-package uniquify
    :straight nil
    :config
    (setq uniquify-buffer-name-style 'forward)
    (setq uniquify-separator "/")
    (setq uniquify-after-kill-buffer-p t)
    (setq uniquify-ignore-buffers-re "^\\*"))
#+end_src
** Icons
#+begin_src emacs-lisp
  (use-package all-the-icons)
#+end_src
*** Dired
#+begin_src emacs-lisp
  (use-package all-the-icons-dired
    :config
    (setq all-the-icons-dired-monochrome nil)
    (add-hook 'dired-mode-hook #'all-the-icons-dired-mode))
#+end_src
*** Completion
#+begin_src emacs-lisp
  (use-package all-the-icons-completion
    :config
    (all-the-icons-completion-mode t))
#+end_src
*** Ibuffer
#+begin_src emacs-lisp
  (use-package all-the-icons-ibuffer
    :config
    (all-the-icons-ibuffer-mode t))
#+end_src
*** TODO Add icons to more files
** TODO WSL
#+begin_src emacs-lisp
  (defvar wsl-user nil)

  (defun wsl-p ()
    (not (eq
          (or (string-match-p "Windows" (getenv "PATH"))
              (string-match-p "Microsoft" (shell-command-to-string "uname -a")))
          nil)))
  (when (wsl-p)
    (setq wsl-user
          (string-trim-right (shell-command-to-string "powershell.exe '$env:UserName'"))))
  (defun wsl-insert-home ()
    (interactive)
    (if (wsl-p)
        (insert (format "/mnt/c/Users/%s/" wsl-user))
      (message "you're not on wsl")))
  (global-set-key (kbd "C-c i w") #'wsl-insert-home)

  (when (wsl-p)
    (setq browse-url-browser-function #'browse-url-generic
          browse-url-generic-program "explorer.exe"))
#+end_src
*** TODO explorer.exe sometimes opens incorrectly
** TODO Emotes
Add emojify https://github.com/iqbalansari/emacs-emojify
** TODO Search engines
#+begin_src emacs-lisp
  (use-package engine-mode
    :config
    (defengine github
      "https://github.com/search?ref=simplesearch&q=%s"
      :keybinding "gh")
    (defengine duckduckgo
      "https://duckduckgo.com/?q=%s"
      :keybinding "d")
    (defengine google
      "https://google.com/search?q=%s"
      :keybinding "go")

    (setq engine/browser-function #'eww-browse-url)
    (engine/set-keymap-prefix (kbd "C-c e")))
#+end_src
*** TODO Make it use the browser outside of WSL
* TODO Spelling and text autocompletion
** Ispell
#+begin_src emacs-lisp
(use-package ispell
  :straight nil)
#+end_src
** Flyspell
TODO: disable when changing modes to a programming mode
#+begin_src emacs-lisp :tangle no
  (use-package flyspell
    :straight nil
    :hook (prog-mode . flyspell-mode))
#+end_src
Use flyspell
** TODO Autocompletion of words
** TODO Automatic checking and fixing
** TODO Automatic selecting of language
* Emacs development
** TODO Refine
Broken
#+begin_src emacs-lisp :tangle no
  (use-package refine
    :config
    (add-hook 'refine-mode-hook #'evil-emacs-state))
#+end_src
* Help
** Show keys
#+begin_src emacs-lisp
  (use-package which-key
    :config
    (which-key-mode)
    (setq which-key-idle-delay 0.5))
#+end_src
** Help buffer
Automatically select the help buffer, so that it'd be easier to close after reading
#+begin_src emacs-lisp
  (setq help-window-select t)
#+end_src
** TODO Helpful
#+begin_src emacs-lisp
  (use-package helpful)
#+end_src
** Function discovery
#+begin_src emacs-lisp
  (use-package suggest)
#+end_src
* TODO Impatient
This mode provides basic live reload support.
#+begin_src emacs-lisp
  (use-package impatient-mode
    :disabled t)
#+end_src
* C
** TODO Uncrustify
Disabled because it needs the uncrustify binary
#+begin_src emacs-lisp
  (use-package uncrustify
    :disabled t)
#+end_src
* Compiling
** RMSBolt
#+begin_src emacs-lisp
  (use-package rmsbolt)
#+end_src
* Reading
** PDF
#+begin_src emacs-lisp
  (use-package pdf-tools ;; This package causes issues
    :magic ("%PDF" . (lambda () (pdf-view-mode) (display-line-numbers-mode 0)))
    :config
    (add-hook 'pdf-tools-enabled-hook 'auto-revert-mode))
#+end_src
** Books
#+begin_src emacs-lisp
  (use-package nov
    :mode ("\\.epub\\'" . nov-mode))
#+end_src
* Buffer / window navigation
** Ibuffer
Ibuffer provides a dired-like interface for working with buffers
#+begin_src emacs-lisp
  (global-set-key (kbd "C-x C-b") 'ibuffer)
#+end_src
** Windmove
Allow navigating windows with Shift-<key arrow>
#+begin_src emacs-lisp
  (windmove-default-keybindings)
#+end_src
** Eyebrowse
Adds workspaces
#+begin_src emacs-lisp
  (use-package eyebrowse
    :config
    (eyebrowse-mode 1))
#+end_src
** ace-window
Manipulate windows with ace
#+begin_src emacs-lisp
  (use-package ace-window
    :bind (("M-o" . ace-window)
           ("C-c w" . ace-window)))
#+end_src
** winner
#+begin_src emacs-lisp
  (use-package winner
    :straight nil
    :config
    (winner-mode t))
#+end_src
** TODO Ediff
#+begin_src emacs-lisp
  (use-package ediff
    :straight nil
    :config
    (setq ediff-window-setup-function 'ediff-setup-windows-plain)
    (setq ediff-split-window-function 'split-window-horizontally))
#+end_src
* Project navigation
** TODO counsel-rg
** Projectile
#+begin_src emacs-lisp
  (use-package projectile
    :diminish
    :config
    (define-key projectile-mode-map (kbd "C-c p") 'projectile-command-map)
    (projectile-mode 1))
#+end_src
*** TODO Remove projectile
Projectile doesn't behave properly and it should be replaced with
something simpler
* Completion
** Recursive
#+begin_src emacs-lisp
  (setq enable-recursive-minibuffers t)
  (setq minibuffer-depth-indicate-mode t)
#+end_src
** Selectrum
#+begin_src emacs-lisp
  (use-package selectrum
    :bind (("C-c ," . #'selectrum-quick-select)
           ("C-c r" . #'selectrum-repeat)
           :map selectrum-minibuffer-map
           ("<escape>" . #'abort-recursive-edit))
    :custom-face
    (selectrum-current-candidate ((t (:foreground "#68f3ca"))))
    :config
    (selectrum-mode t))
#+end_src
*** TODO Make functions like find-file work like in Ivy (backspaces goes to parent)
*** TODO Fix the theme
*** Marginalia
#+begin_src emacs-lisp
(use-package marginalia
  :config
  (marginalia-mode t))
#+end_src
*** Prescient
#+begin_src emacs-lisp
  (use-package prescient
    :config
    (prescient-persist-mode t))
  (use-package selectrum-prescient
    :config
    (selectrum-prescient-mode t))
#+end_src
** Consult
#+begin_src emacs-lisp
  (use-package consult
    :bind (("C-x b" . consult-buffer)
           ("C-c m" . consult-imenu)
           ("C-c s" . consult-line)
           ("C-x M-:" . consult-complex-command)))
  (use-package consult-dir
    :bind (("C-c d" . #'consult-dir)))
  (use-package consult-company
    :after (consult company))
  (use-package consult-flycheck)
#+end_src
* Embark
#+begin_src emacs-lisp
  (use-package embark
    :bind (("C-c ." . #'embark-act)
           ("C-h B" . #'embark-bindings)))
  (use-package embark-consult
    :after embark consult)
#+end_src
* Aesthetics
** Font
Use system font
#+begin_src emacs-lisp
  (set-face-attribute 'default nil :height 100)
#+end_src
** Colorscheme
#+begin_src emacs-lisp
(use-package kaolin-themes
  :config
  (load-theme 'kaolin-shiva t))
#+end_src
** Editor frame
Make Emacs more minimalist
#+begin_src emacs-lisp
  (scroll-bar-mode 0)
  (tool-bar-mode 0)
  (menu-bar-mode 0)
  (blink-cursor-mode 0) ; disable cursor blinking
#+end_src

Add some widgets
#+begin_src emacs-lisp
  ;;(global-hl-line-mode 1)
  (column-number-mode 1)
  (size-indication-mode 1)
#+end_src
** Fringe
*** Size
#+begin_src emacs-lisp
  (set-fringe-mode 8)
#+end_src
*** EOF
#+begin_src emacs-lisp
  (setq-default indicate-empty-lines t)
#+end_src
*** TODO git gutter
** Frame title
#+begin_src emacs-lisp
  (setq-default frame-title-format "%b (%f)") ; add a bit better frame title
#+end_src
** Bell
#+begin_src emacs-lisp
  (setq ring-bell-function (lambda ()))
  (setq visible-bell nil)
#+end_src
** Line numbers
#+begin_src emacs-lisp
  (setq-default display-line-numbers-type 'relative)
  (add-hook 'prog-mode-hook #'display-line-numbers-mode)
#+end_src
** Save place
#+begin_src emacs-lisp
  (save-place-mode t)
#+end_src
** Modeline
#+begin_src emacs-lisp
  (use-package doom-modeline
    :config
    (doom-modeline-mode t))
#+end_src
*** clock
#+begin_src emacs-lisp
  (use-package display-time
    :no-require t
    :straight nil
    :init
    (setq display-time-24hr-format t)
    (setq display-time-day-and-date t)
    (setq display-time-default-load-average nil)
    :config
    (display-time-mode t))
#+end_src
* Org
TODO: fix speed commands
TODO: configure maintaining the ~/org/ directory
TODO: uncomment and test org-log logging
#+begin_src emacs-lisp
  ;; (setq org-use-speed-commands t)
  (setq org-startup-indented t)
  ;; (setq org-log-into-drawer t)
  ;; (setq org-log-done 'time)
  (setq org-support-shift-select t)
  ;; (setq org-directory "~/org/")
  ;; (setq org-agenda-files '("~/org/"))
  (setq org-hide-emphasis-markers nil)
#+end_src
** Evil
#+begin_src emacs-lisp
  ;; TODO: add make blocks cycleable from evil normal mode
#+end_src
** Babel
#+begin_src emacs-lisp
(setq org-src-tab-acts-natively t)
(setq org-src-preserve-indentation nil)
(setq org-src-window-setup 'current-window)
#+end_src
*** Source blocks
#+begin_src emacs-lisp
  (setq org-structure-template-alist ())
  (add-to-list 'org-structure-template-alist '("e" . "src emacs-lisp"))
  (add-to-list 'org-structure-template-alist '("s" . "src sh"))
#+end_src
*** Exporting
**** HTML
Allow exporting to HTML
#+begin_src emacs-lisp
  (use-package htmlize)
#+end_src
* Evil
#+begin_src emacs-lisp
  (use-package evil
    :config
    (evil-mode t))
#+end_src
** Lispy
#+begin_src emacs-lisp
  (use-package evil-lispy
    :hook (emacs-lisp-mode . evil-lispy-mode))
#+end_src
* Dired
#+begin_src emacs-lisp
  (use-package dired
    :straight nil
    :no-require t)
#+end_src
** Narrowing
#+begin_src emacs-lisp
  (use-package dired-narrow
    :bind (:map dired-mode-map
                (")" . #'dired-narrow)))
#+end_src
** Omit
#+begin_src emacs-lisp
  (use-package dired-x
    :straight nil
    :bind (:map dired-mode-map
                ("O" . #'dired-omit-mode))
    :config
    (setq dired-omit-files "^\\...+$")
    (add-to-list 'dired-omit-extensions ".eld")
    (add-hook 'dired-mode-hook #'dired-omit-mode))
#+end_src
** DWIM
#+begin_src emacs-lisp
  (setq dired-dwim-target t)
#+end_src
** Details
#+begin_src emacs-lisp
  (add-hook 'dired-mode-hook #'dired-hide-details-mode)
  (use-package dired-collapse
    :hook (dired-mode . dired-collapse))
  (use-package dired-subtree
    :bind (:map dired-mode-map
                (("i" . 'dired-subtree-insert)
                 ("I" . 'dired-subtree-remove))))
#+end_src
** Interacting with the outside
#+begin_src emacs-lisp
  (setq dired-auto-revert-buffer t)
#+end_src
* Terminal
** Vterm
#+begin_src emacs-lisp
  (use-package vterm
    :when (eq system-type 'gnu/linux)
    :config
    (setq-default vterm-exit-functions #'kill-buffer)
    (setq vterm-kill-buffer-on-exit t)
    (evil-set-initial-state 'vterm-mode 'emacs))
#+end_src
*** eshell-vterm
#+begin_src emacs-lisp
  (use-package eshell-vterm
    :config
    (eshell-vterm-mode)
    (defalias 'eshell/v 'eshell-exec-visual))
#+end_src
**** TODO [#A] Fix error when exiting buffer
** Eshell
#+begin_src emacs-lisp
    ;;; -*- legical-binding: t; -*-

  (use-package eshell
    :straight nil
    :config
    (setq eshell-scroll-to-bottom-on-input t)
    (setq eshell-banner-message ""))

  (defun eshell-current-p ()
    (eq major-mode 'eshell-mode))

  (defvar eshell-binds ()
    "Contains pairs of keys and functions")

  (defun eshell-bind-initialize ()
    (dolist (bind eshell-binds)
      (define-key eshell-mode-map (kbd (car bind)) (cadr bind)))
    ())

  (defun eshell-bind (key function)
    (add-to-list 'eshell-binds (list key function))
    (when (eq major-mode 'eshell-mode)
      (eshell-bind-initialize))
    nil)

  (add-hook 'eshell-mode-hook #'eshell-bind-initialize)

  (eshell-bind "<tab>" #'completion-at-point)
  (eshell-bind "C-M-i" #'completion-at-point)
#+end_src
*** Up
#+begin_src emacs-lisp
  (use-package eshell-up
    :config
    (defalias 'eshell/up #'eshell-up))
#+end_src
*** Clear
Clear the eshell buffer
#+begin_src emacs-lisp
  (defun eshell/nuke ()
    "Clear the eshell buffer."
    (interactive)
    (when (eshell-current-p)
      (let ((inhibit-read-only t))
        (erase-buffer)
        (eshell-send-input)
        (delete-region 1 2))))

  (eshell-bind "M-l" #'eshell/nuke)
#+end_src
*** Last
Go to the last line of the window
#+begin_src emacs-lisp
  (defun eshell/last ()
    "Clear the window"
    (interactive)
    (goto-char (point-max))
    (deactivate-mark)
    (recenter 0))

  (eshell-bind "C-l" #'eshell/last)
#+end_src
*** TODO img
This shows an extra shell prompt
#+begin_src emacs-lisp
  (defun eshell/img (img-path)
    (let ((path (expand-file-name img-path))
          img)
      (setq img (create-image path))
      (setf (image-property img :scale) .25)
      (save-excursion
        (insert-image img))
      (eshell-send-input))
    nil)
#+end_src
**** TODO Fix sizing of images
Currently only big images look normal
**** TODO Disable showing two prompts after image
*** TODO Backspace
Pressing backspace on an empty prompt should send the user to the previous prompt
#+begin_src emacs-lisp :tangle no
  (defun eshell--backspace ()
    (interactive)
    (if (get-char-property (- (point) 1) 'read-only)
        (eshell-previous-prompt 1)
      (backward-delete-char-untabify 'untabify)))

  (eshell-bind "M-<left>" #'eshell-previous-prompt)
  (eshell-bind "M-<right>" #'eshell-next-prompt)
#+end_src
*** M-x
Run emacs commands from eshell
#+begin_src emacs-lisp
  (defun eshell/run (&optional command)
    (if command
        (call-interactively (intern command))
      (error "No command")))
#+end_src
*** C-d
#+begin_src emacs-lisp
  (defun eshell-C-d () (interactive) (if (eq (point) (point-max)) (eshell-life-is-too-much) (delete-char 1)))
  (add-hook 'eshell-mode-hook (lambda () (local-set-key (kbd "C-d") 'eshell-C-d)))
#+end_src
*** View
View a file in a read-only window with syntax highlighting
**** TODO Kill buffer and window after pressing q
#+begin_src emacs-lisp
  (defun eshell/view (filename)
    (let ((opened (get-file-buffer filename))))
    (with-current-buffer (find-file-noselect filename)
      (view-mode)
      (switch-to-buffer-other-window (current-buffer))
      (local-set-key (kbd "q") #'kill-buffer-and-window)
      ()))
#+end_src
* Programming
** LSP
#+begin_src emacs-lisp
  (use-package lsp-mode)
  (use-package lsp-ui
    :after lsp-mode)
#+end_src
** Lisp
*** Sly
#+begin_src emacs-lisp
  (setq inferior-lisp-program "sbcl")
  (use-package sly
    :config
    (add-hook 'sly-db-hook #'evil-emacs-state))
#+end_src
** Universal
*** Indentation
#+begin_src emacs-lisp
  (setq-default tab-width 4)
  (setq-default indent-tabs-mode nil)

  (use-package aggressive-indent
    :config
    (global-aggressive-indent-mode 1))
#+end_src
*** Parenthesis
#+begin_src emacs-lisp
  (electric-pair-mode 1)
  (show-paren-mode 1)
#+end_src
*** Completion
#+begin_src emacs-lisp
  (use-package company
    :bind (("M-SPC" . #'company-complete))
    :hook (prog-mode . company-mode)
    :config
    (setq company-dabbrev-downcase 0)
    (setq company-idle-delay .3)
    (setq company-minimum-prefix-length 1))
  (use-package company-prescient
    :config
    (company-prescient-mode t))
#+end_src
**** TODO Use counsel-company
*** Error checking
TODO: Fix for elisp
#+begin_src emacs-lisp
  (use-package flycheck
    :init
    :config
    (global-flycheck-mode 0)
    (setq-default flycheck-disabled-checkers '(emacs-list-checkdoc)))
#+end_src
** Web
*** TypeScript
#+begin_src emacs-lisp
  (use-package tide
    :init
    (setq typescript-indent-level 4)
    :config
    (add-hook 'typescript-mode-hook (lambda () (tide-mode 1))))
#+end_src
* Git
TODO: add magit-forge
#+begin_src emacs-lisp
  (use-package magit
    :config
    (global-set-key (kbd "C-x g") 'magit-status))
#+end_src
** git gutter
TODO: fix showing modified lines
#+begin_src emacs-lisp
  (use-package git-gutter
    :diminish
    :config
    (global-git-gutter-mode t)
    (set-face-background 'git-gutter:modified 'nil)
    (set-face-foreground 'git-gutter:added "green4")
    (set-face-foreground 'git-gutter:deleted "red"))
#+end_src
* Text editing
** TODO multiple-cursors
Add it and make it compatible with Evil
** Olivetti
TODO: make it wider
TODO: disable line numbers
#+begin_src emacs-lisp
  (use-package olivetti)
#+end_src
** avy
#+begin_src emacs-lisp
  (use-package avy
    :bind ("C-:" . #'avy-goto-char-timer))
#+end_src
** ace-link
#+begin_src emacs-lisp
  (use-package ace-link
    :bind ("C-c l" . #'ace-link))
#+end_src
** move-text
#+begin_src emacs-lisp
  (use-package move-text
    :config
    (move-text-default-bindings))
#+end_src
** TODO snippets
#+begin_src emacs-lisp
  (use-package yasnippet)
#+end_src
* Web services
** Pastebins
Easy access to pastebins
#+begin_src emacs-lisp
  (use-package webpaste)
#+end_src
* Hydras
** Install
#+begin_src emacs-lisp
  (use-package hydra)
#+end_src
** Scripts
No hydras yet
** TODO Find an alternative
Is this even necessary?
* Useful tools
** TODO Crux
#+begin_src emacs-lisp
  (use-package crux)
#+end_src
** Devdocs
TODO: consider using devdocs-browser instead
#+begin_src emacs-lisp
  (use-package devdocs)
#+end_src
** Playground
#+begin_src emacs-lisp
  ;; TODO: add a playground minor mode with various features like in smalltalk's playground

  (defvar playground-default-name "playground"
    "Name that will be used for a playground buffer, if no name is
  specified in the function call.")
  (defvar playground-default-separator ":"
    "Character(s) that will be used adding an index to a playground buffer name.")
  (defvar playground-reuse-playgrounds nil
    "Non-nil if playgrounds should reuse names of closed playgrouds, otherwise a counter of previously opened playgrounds will be used.")
  (defvar playground--count 0
    "Count of playgrounds that have already been opened.")

  (defun playground-uniquify-name (name &optional separator)
    (when (not separator)
      (setq separator playground-default-separator))
    (if playground-reuse-playgrounds
        (progn
          (let ((i 1)
                (buffer-name))
            (while (get-buffer (setq buffer-name (concat name separator (number-to-string i))))
              (setq i (1+ i)))
            buffer-name))
      (let ((buffer-name (concat name separator (number-to-string playground--count))))
        (if (get-buffer buffer-name)
            (playground-uniquify-name name (concat separator separator))
          (setq playground--count (1+ playground--count))
          buffer-name))))

  (defun playground (&optional name)
    (interactive)

    (when (not name)
      (setq name playground-default-name))
    (let* ((buffer-name (playground-uniquify-name name))
           (buffer (get-buffer-create buffer-name)))
      (with-current-buffer buffer (emacs-lisp-mode))
      (pop-to-buffer buffer)))
#+end_src
* no-littering
#+begin_src emacs-lisp
  (use-package no-littering
    :config
    (add-to-list 'recentf-exclude no-littering-var-directory)
    (add-to-list 'recentf-exclude no-littering-etc-directory)

    (setq auto-save-file-name-transforms
          `((".*" ,(no-littering-expand-var-file-name "auto-save/") t)))
    (setq custom-file (no-littering-expand-etc-file-name "custom.el"))
    (setq backup-directory-alist `(("." . ,(no-littering-expand-var-file-name "backups")))))
#+end_src
